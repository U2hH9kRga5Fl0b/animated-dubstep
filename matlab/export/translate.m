% This function loads a file generated by the UI team, and creates a city out of it.
% The argument needs to end with the path separator for your
% The argument is the directory containing files named 'output1.txt', 'output2.txt', ...

function [c] = translate(dirname)


% Questions for the UI team.

% High priority:
%	Split up output3.txt to also have an output4.txt
%	I don't see any information about truck types/number of trucks.
% Medium priority:
%	No addresses for landfills/staging areas.
% Low priority:
%	distacnes are not same time units as wait times (just assume you have to multiply the wait times by 60?)
%

file1 = [dirname filesep 'output1.txt'];
file2 = [dirname filesep 'output2.txt'];
file3 = [dirname filesep 'output3.txt'];
file4 = [dirname filesep 'output4.txt'];

R = get_num_lines(file2) - 1; % -1 for the header
Y = get_num_lines(file3) - 1;
L = get_num_lines(file4) - 1;
D = 10; % This is not given in the UI team's output yet.

m = R + Y + L;
n = R + 8 * Y + 4 * L;

dumpsters = [6, 9, 12, 16];
ndumpsters = length(dumpsters);
ntrucks = 3; 

c = city;
c.addresses = {};
c.number_of_locations = m;
c.number_of_actions = n;
c.number_of_requests = R;
c.number_of_staging_areas = Y;
c.number_of_drivers = D;
c.number_of_landfills = L;
c.start_location = L + 1; % It looks like the landfills come before the staging areas.

c.max_time = 60 * 60 * 14; % Seconds in a day- should it be a 12 hour day?
c.truck_types = [ 1 1 2 2 2 2 2 2 3 3];


yards_wait_time = 10 * 60; % ten minutes
requests_wait_time = 10 * 60; % ten minutes


for i=1:Y+L
    % This is Bailey, CO.
	c.locs(i,:) = [39.4105578 -105.4794795];
end



c.durations = zeros(m, m);
c.distances = zeros(m, m);

line=1;
%Parse output1
fid=fopen(file1, 'r');
if fid < 0
    error('unable to open %s\n', file1);
end
fgetl(fid); % ignore the first line
tline=fgetl(fid);

while ischar(tline)
    [comps, len] = strsplit(tline, '\t');
    
    if size(len, 2) + 1 ~= 4
        warning('Line %d output1 has the wrong number of columns!\nline=%s', line+1, tline);
        line = line + 1;
        tline = fgetl(fid);
        continue;
    end
    if strfind(tline, '#VALUE!')
        warning('Line %d of output1.txt has a NAN. This will be distance 0.', line+1);
        line = line + 1;
        tline = fgetl(fid);
        continue;
    end
    
    idx1 = cast(str2num(comps{1}), 'int32');
    idx2 = cast(str2num(comps{2}), 'int32');
        
	if idx1 < 1 || idx2 < 1 || idx1 > m || idx2 > m
        warning('Bad input on line %d of input1.txt', r);
        line = line + 1;
        tline = fgetl(fid);
        continue;
    end
        
	if c.distances(idx1, idx2) ~= 0.0 || c.durations(idx1, idx2) ~= 0.0
        warning(['Possibly overwriting values in %d,%d in line %d.\n' ...
            'The previous values were t=%f d=%f'], ...
            idx1, idx2, line, c.durations(idx1, idx2), c.distances(idx1, idx2));
    end
    
    
	c.distances(idx1, idx2) = str2num(comps{3});
	c.durations(idx1, idx2) = str2num(comps{4});
    
    line = line + 1;
    tline = fgetl(fid);
end


asymmetry = c.distances - c.distances';
asymmetry = sqrt(sum(sum(asymmetry .* asymmetry)));
% asymmetry





c.location_to_landfill = cast(zeros(1, m), 'int32');
c.location_to_stagingarea = cast(zeros(1, m), 'int32');

c.actions = action.empty(n, 0);
c.yards = staging_area.empty(Y, 0);
c.landfills = landfill.empty(L, 0);

%Initialize the actions with an empty array
next_action_index   = cast(1, 'uint32');


line=1;
%Parse output4
fid=fopen(file4, 'r');
if fid < 0
    error('unable to open %s\n', file4);
end
fgetl(fid); % ignore the first line
tline=fgetl(fid);
while ischar(tline)
    comps = strsplit(tline, '\t');
    % Landfill,Wait time,Fee
    c.landfills(line).location = str2num(comps{1});
    wait = str2num(comps{2}) * 60;
    c.landfills(line).fee = str2num(comps{3});
    
    for j = 1:ndumpsters
        c.actions(next_action_index).operation   = 'E';
        c.actions(next_action_index).in_size     = dumpsters(j);
        c.actions(next_action_index).out_size    = dumpsters(j);
        c.actions(next_action_index).start_time  = 0;
        c.actions(next_action_index).stop_time   = c.max_time;
        c.actions(next_action_index).wait_time   = wait;
        c.actions(next_action_index).location    = c.landfills(line).location;
        c.actions(next_action_index).allowable_truck_types = ones(1, ntrucks);
        
        next_action_index = next_action_index + 1;
    end
    
    c.addresses = [ c.addresses {'no addresses for landfills'} ];
    c.location_to_landfill(c.landfills(line).location) = line;
    line = line + 1;
    tline = fgetl(fid);
end



line=1;
%Parse output3
fid=fopen(file3, 'r');
if fid < 0
    error('unable to open %s\n', file3);
end
fgetl(fid); % ignore the first line
tline=fgetl(fid);
while ischar(tline)
    [comps, len] = strsplit(tline, '\t');
    if size(len, 2) + 1 ~= 6
        warning('Line %d of output3.txt has the wrong number of columns!\nline=%s', line, tline);
        line = line + 1;
        tline = fgetl(fid);
        continue;
    end
    
    % Storage location,Capacity,6,9,12,16
    c.addresses = [ c.addresses {'no address for staging areas'} ];
    
    
    c.yards(line).location = str2num(comps{1});
    c.yards(line).capacity = str2num(comps{2});
    c.yards(line).inventory = [
                str2num(comps{3}) ...
                str2num(comps{4}) ...
                str2num(comps{5}) ...
                str2num(comps{6}) ];
    
    for j = 1:ndumpsters
        c.actions(next_action_index).operation   = 'S';
        c.actions(next_action_index).in_size     = dumpsters(j);
        c.actions(next_action_index).out_size    = 0;
        c.actions(next_action_index).start_time  = 0;
        c.actions(next_action_index).stop_time   = c.max_time;
        c.actions(next_action_index).wait_time   = yards_wait_time;
        c.actions(next_action_index).location    = c.yards(line).location;
        c.actions(next_action_index).allowable_truck_types = ones(1,ntrucks);
        
        next_action_index = next_action_index + 1;
        
        c.actions(next_action_index).operation   = 'U';
        c.actions(next_action_index).in_size     = 0;
        c.actions(next_action_index).out_size    = dumpsters(j);
        c.actions(next_action_index).start_time  = 0;
        c.actions(next_action_index).stop_time   = c.max_time;
        c.actions(next_action_index).wait_time   = yards_wait_time;
        c.actions(next_action_index).location    = c.yards(line).location;
        c.actions(next_action_index).allowable_truck_types = ones(1,ntrucks);
        
        next_action_index = next_action_index + 1;
    end
    
    c.location_to_stagingarea(c.yards(line).location) = line;
    line = line + 1;
    tline = fgetl(fid);
end


%parse requests...
line=1;
fid=fopen(file2, 'r');
if fid < 0
    error('unable to open %s\n', file2);
end
fgetl(fid); % ignore the first line
tline=fgetl(fid);
while ischar(tline)
    % Index,address,In,Out,Small,Not Small,Time Window
	comps = strsplit(tline, '\t');
    
    c.actions(next_action_index).location = str2num(comps{1});
    assert(line + L + Y == str2num(comps{1}), 'Requests not in the order we expected.');
    
    c.addresses = { c.addresses{:} comps{2}};
	[c.locs(line + Y + L,:), ~] = address_to_location(comps{2}, true);
    c.actions(next_action_index).in_size = str2num(comps{3});
    c.actions(next_action_index).out_size = str2num(comps{4});
    
    if c.actions(next_action_index).in_size == 0
        c.actions(next_action_index).operation = 'P';
    elseif c.actions(next_action_index).out_size == 0
        c.actions(next_action_index).operation = 'D';
    else
        c.actions(next_action_index).operation = 'R';
    end
    
    switch comps{7}
        case 'am'
            c.actions(next_action_index).start_time  = cast(0, 'uint32');
            c.actions(next_action_index).stop_time   = cast(c.max_time / 2, 'uint32');
        case 'pm'
            c.actions(next_action_index).start_time  = cast(c.max_time / 2, 'uint32');
            c.actions(next_action_index).stop_time   = cast(0, 'uint32');
        case 'OPEN' 
            c.actions(next_action_index).start_time  = cast(0, 'uint32');
            c.actions(next_action_index).stop_time   = cast(c.max_time, 'uint32');
        otherwise
            warning('Do not know how to parse %s\n', tline);
    end
    
    c.actions(next_action_index).wait_time = requests_wait_time;
    
    if str2num(comps{6}) % needs to be a big truck
        c.actions(next_action_index).allowable_truck_types = [zeros(1, ntrucks-1) 1];
    elseif str2num(comps{5}) % needs to be a small truck
        c.actions(next_action_index).allowable_truck_types = [1 zeros(1, ntrucks-1)];
    else
        c.actions(next_action_index).allowable_truck_types = ones(1,ntrucks);
    end
    
    % move to the next action/location
    next_action_index   = next_action_index   + 1;
    tline = fgetl(fid);
    line = line + 1;
end



end